<!doctype html>

<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
<title>Roguechain — Dice Roll Edition (Scenarios x4, Mobile)</title>
<style>
  :root{
    --bg:#0b0f14;--panel:#0f1620;--panel2:#0d141d;--ink:#e6edf3;--muted:#9aa5b1;--accent:#72a1ff;--good:#42d392;--bad:#ff6b6b;--edge:#1f2a37
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{margin:0;font-family:Inter,system-ui,Segoe UI,Roboto,Arial,sans-serif;background:var(--bg);color:var(--ink);-webkit-tap-highlight-color:transparent}
  .wrap{max-width:960px;margin:0 auto;padding:16px}
  header{display:flex;flex-wrap:wrap;gap:10px;align-items:center;justify-content:space-between;margin-bottom:12px}
  .brand{font-weight:800;letter-spacing:.3px;font-size:clamp(16px,2.5vw,20px)}
  .wallet{display:flex;flex-wrap:wrap;gap:8px;align-items:center}
  .pill{background:var(--panel);border:1px solid var(--edge);padding:8px 10px;border-radius:10px;display:flex;gap:8px;align-items:center;font-size:14px}
  button{background:var(--panel2);border:1px solid var(--edge);border-radius:12px;padding:10px 14px;color:var(--ink);cursor:pointer;font-weight:600}
  button:active{transform:scale(0.98)}
  button:hover{border-color:#315a9f}
  button.primary{background:#1b2736;border-color:#315a9f}
  main{display:grid;grid-template-columns:1.2fr .8fr;gap:12px}
  @media (max-width:860px){main{grid-template-columns:1fr}}
  .card{background:var(--panel);border:1px solid var(--edge);border-radius:14px;padding:12px}
  h2{margin:0 0 8px;font-size:18px}
  .stats{display:grid;grid-template-columns:repeat(3,1fr);gap:8px;margin:8px 0}
  @media (max-width:480px){.stats{grid-template-columns:repeat(2,1fr)}}
  .stat{background:var(--panel2);border:1px solid var(--edge);border-radius:12px;padding:8px;text-align:center;font-size:14px}
  .choices{display:flex;flex-direction:column;gap:8px;margin-top:8px}
  .choices button{width:100%;text-align:left;display:flex;justify-content:space-between;align-items:center;gap:10px}
  .choices .req{opacity:.8;font-size:12px}
  .log{max-height:300px;overflow:auto;background:var(--panel2);border:1px solid var(--edge);border-radius:12px;padding:10px;font:13px/1.5 ui-monospace,Consolas,Menlo,monospace}
  .log .good{color:var(--good)}
  .log .bad{color:var(--bad)}
  .row{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
  .hint{color:var(--muted);font-size:12px}
  .divider{height:1px;background:var(--edge);margin:8px 0}
  .tombstones{font:13px/1.4 ui-monospace,Consolas,Menlo,monospace}
  .muted{color:var(--muted)}
  /* Dice tray */
  .check{background:var(--panel2);border:1px dashed var(--edge);border-radius:12px;padding:10px}
  .tray{display:flex;gap:12px;align-items:center;flex-wrap:wrap;margin-top:8px}
  .die{width:64px;height:64px;border-radius:14px;background:var(--panel);border:2px solid var(--edge);display:flex;align-items:center;justify-content:center;font:700 20px/1 ui-monospace,Consolas;position:relative;user-select:none}
  .die .label{position:absolute;bottom:4px;left:6px;font:10px/1.2 ui-monospace;color:var(--muted)}
  .die .value{font-size:20px}
  .die.armed{outline:2px solid var(--accent);box-shadow:0 0 0 4px rgba(114,161,255,.12)}
  .die.disabled{opacity:.5}
  .die.rolling{animation:shake .9s ease-in-out}
  @keyframes shake{0%{transform:rotate(0)}25%{transform:rotate(8deg)}50%{transform:rotate(-8deg)}75%{transform:rotate(5deg)}100%{transform:rotate(0)}}
  @media (max-width:480px){.die{width:56px;height:56px}.die .value{font-size:18px}}
  /* Scenario box */
  .scenario{background:var(--panel2);border:1px solid var(--edge);border-radius:12px;padding:10px}
  .scenario h3{margin:0 0 6px;font-size:16px}
  .scenario p{margin:0;color:#c8d0d8}
  .tag{display:inline-block;background:#1a2432;border:1px solid #2a3a52;border-radius:999px;padding:3px 8px;margin-right:6px;font-size:11px;color:#9fb4d6}
</style>
</head>
<body>
  <div class="wrap">
    <header>
      <div class="brand">Roguechain — Dice Roll Edition</div>
      <div class="wallet">
        <div class="pill" id="balance">Balance: 0.00 FAKE</div>
        <button id="btnFaucet">Add Test Coins</button>
        <button id="btnWithdraw">Withdraw 5.00</button>
      </div>
    </header><main>
  <section class="card">
    <h2>Adventure</h2>
    <div class="row">
      <button id="btnStart" class="primary">Start Run (Pay Entry Fee)</button>
      <div class="pill" id="entryFee">Entry fee: 5.00 FAKE</div>
      <div class="pill" id="pass">No Character Pass</div>
    </div>

    <div class="stats">
      <div class="stat">HP <div id="sHP">—</div></div>
      <div class="stat">Rations <div id="sR">—</div></div>
      <div class="stat">Light <div id="sL">—</div></div>
      <div class="stat">Resolve <div id="sRV">—</div></div>
      <div class="stat">Gold <div id="sG">—</div></div>
      <div class="stat">Depth <div id="sD">—</div></div>
    </div>

    <div id="campRow" class="row" style="display:none">
      <button id="btnRetire">Retire at Camp (Cash Out)</button>
      <span class="hint">Camps appear every 4 depths. Retire here to bank your gold into your wallet.</span>
    </div>

    <div class="scenario" id="scenarioBox" style="display:none">
      <div class="row" style="justify-content:space-between;align-items:center">
        <h3 id="scTitle" style="margin:0">—</h3>
        <div id="scTags"></div>
      </div>
      <p id="scText">—</p>
    </div>

    <div class="divider"></div>
    <div class="choices" id="choices"></div>

    <div class="divider"></div>
    <div class="check" id="checkBox" style="display:none">
      <div id="checkText" class="hint">—</div>
      <div class="tray" aria-label="Dice tray">
        <div class="die" id="d6" data-sides="6" role="button" aria-label="Roll d6"><span class="value">d6</span><span class="label">d6</span></div>
        <div class="die" id="d12" data-sides="12" role="button" aria-label="Roll d12"><span class="value">d12</span><span class="label">d12</span></div>
        <div class="die" id="d20" data-sides="20" role="button" aria-label="Roll d20"><span class="value">d20</span><span class="label">d20</span></div>
      </div>
      <div class="hint">Tap the highlighted die to roll. Meet or beat the DC to succeed.</div>
    </div>

    <div class="divider"></div>
    <div class="log" id="log"></div>
  </section>

  <aside class="card">
    <h2>How it works</h2>
    <ul class="muted">
      <li>Every turn spawns a fresh <b>scenario</b> with <b>4 choices</b> (Safe / Bold / Risky / Wild).</li>
      <li>Each choice sets a <b>dice check</b> (die + DC). Tap the die to resolve.</li>
      <li>Camps every 4 depths let you <b>Retire</b> and bank loot to your wallet.</li>
      <li>If you die, you lose unbanked loot and your pass burns (permadeath).</li>
    </ul>
    <div class="divider"></div>
    <h2>Tombstones</h2>
    <div class="tombstones" id="tombstones">—</div>
  </aside>
</main>

<p class="hint" style="margin-top:10px">All data (wallet, tombstones) is stored locally in your browser (localStorage). Token: <b>FAKE</b>.</p>

  </div><script>
(function(){
  // ---------- Helpers & Storage ----------
  const $ = sel => document.querySelector(sel);
  const fmtMinor = (m) => `${(m/100).toFixed(2)} FAKE`;
  const store = {
    key: 'rc-web-dice-scenarios-v1',
    load(){ try{ return JSON.parse(localStorage.getItem(this.key)||'{}'); }catch(_){ return {}; } },
    save(obj){ localStorage.setItem(this.key, JSON.stringify(obj)); }
  };

  // ---------- Global State ----------
  const state = {
    walletMinor: 0,
    entryFeeMinorBase: 500,
    pass: null,
    run: null,
    tombstones: [],
    pendingCheck: null,
    recentScenarios: [] // cooldown list of scenario IDs to avoid repeats
  };
  Object.assign(state, store.load());
  if(!Array.isArray(state.tombstones)) state.tombstones = [];
  if(!Array.isArray(state.recentScenarios)) state.recentScenarios = [];

  function persist(){ store.save({ walletMinor: state.walletMinor, tombstones: state.tombstones, recentScenarios: state.recentScenarios }); }

  // ---------- Run Model ----------
  function newRun(runId){
    return { runId, depth:0, hp:10, resolve:5, rations:3, light:3, gold:0, flags:new Set(), alive:true, log:[], scenario:null };
  }
  function isCampDepth(d){ return d>0 && d%4===0; }
  function addLog(rs, msg, cls){ rs.log.push(`<span class="${cls||''}">${msg}</span>`); }

  // ---------- Elements ----------
  const elBal = $('#balance');
  const elEntry = $('#entryFee');
  const elPass = $('#pass');
  const elStart = $('#btnStart');
  const elFaucet = $('#btnFaucet');
  const elWithdraw = $('#btnWithdraw');
  const elRetire = $('#btnRetire');
  const elCampRow = $('#campRow');
  const elChoices = $('#choices');
  const elLog = $('#log');
  const sHP=$('#sHP'), sR=$('#sR'), sL=$('#sL'), sRV=$('#sRV'), sG=$('#sG'), sD=$('#sD');
  const elTombs = $('#tombstones');
  const checkBox = $('#checkBox');
  const checkText = $('#checkText');
  const diceEls = [$('#d6'), $('#d12'), $('#d20')];
  const scBox = $('#scenarioBox');
  const scTitle = $('#scTitle');
  const scText = $('#scText');
  const scTags = $('#scTags');

  function dynamicEntryFee(){ const jitter = Math.floor(Math.random()*50); return Math.max(100, state.entryFeeMinorBase + jitter); }
  let lastFee = dynamicEntryFee();

  function updateWallet(){ elBal.textContent = `Balance: ${fmtMinor(state.walletMinor)}`; }

  function refreshUI(){
    elEntry.textContent = `Entry fee: ${fmtMinor(lastFee)}`;
    elPass.textContent = state.pass ? `Character Pass #${state.pass.runId}` : 'No Character Pass';
    updateWallet();

    if(!state.run){
      sHP.textContent='—'; sR.textContent='—'; sL.textContent='—'; sRV.textContent='—'; sG.textContent='—'; sD.textContent='—';
      elLog.innerHTML=''; elChoices.innerHTML=''; elCampRow.style.display='none'; checkBox.style.display='none'; scBox.style.display='none';
      diceEls.forEach(el=>{ el.classList.remove('armed'); el.querySelector('.value').textContent = `d${el.dataset.sides}`; });
      return;
    }
    const rs = state.run;
    sHP.textContent = rs.hp; sR.textContent=rs.rations; sL.textContent=rs.light; sRV.textContent=rs.resolve; sG.textContent=rs.gold; sD.textContent=rs.depth;
    elLog.innerHTML = rs.log.slice(-200).map(x=>`• ${x}`).join('<br>');
    elCampRow.style.display = (isCampDepth(rs.depth) && rs.alive) ? 'flex':'none';
    checkBox.style.display = state.pendingCheck ? 'block' : 'none';
    diceEls.forEach(el=>{
      const need = state.pendingCheck?.die;
      el.classList.toggle('armed', Number(el.dataset.sides)===need);
      el.classList.toggle('disabled', !!state.pendingCheck && Number(el.dataset.sides)!==need);
    });

    if(rs.scenario){
      scBox.style.display='block';
      scTitle.textContent = rs.scenario.title;
      scText.textContent = rs.scenario.text;
      scTags.innerHTML = rs.scenario.tags.map(t=>`<span class="tag">${t}</span>`).join('');
    } else { scBox.style.display='none'; }
  }

  function renderChoices(rs, choices){
    elChoices.innerHTML='';
    choices.forEach(c=>{
      const btn=document.createElement('button');
      const req=document.createElement('span'); req.className='req'; req.textContent=`${c.risk} · d${c.die} ≥ ${c.dc}`;
      btn.appendChild(document.createTextNode(c.text));
      btn.appendChild(req);
      btn.onclick=()=>{ armCheck(c); };
      elChoices.appendChild(btn);
    });
  }

  function armCheck(check){
    state.pendingCheck = check; // {text, die, dc, risk, resolve}
    checkText.textContent = `Check: ${check.text} — roll d${check.die} and meet DC ${check.dc} (${check.risk})`;
    Array.from(elChoices.querySelectorAll('button')).forEach(b=>b.disabled=true);
    refreshUI();
  }

  function animateRoll(el, sides, done){
    const valEl = el.querySelector('.value');
    el.classList.add('rolling');
    let t=0; const dur=900; const step=70;
    const tick = ()=>{
      t+=step; valEl.textContent = 1+Math.floor(Math.random()*sides);
      if(t>=dur){ const final = 1+Math.floor(Math.random()*sides); valEl.textContent = final; el.classList.remove('rolling'); done(final);} else setTimeout(tick, step);
    };
    tick();
  }

  diceEls.forEach(el=>{
    el.addEventListener('click', ()=>{
      const rs = state.run; if(!rs || !rs.alive) return;
      const chk = state.pendingCheck; if(!chk) return;
      const sides = Number(el.dataset.sides);
      if(sides !== chk.die){ addLog(rs, `Wrong die selected (need d${chk.die}).`, 'bad'); refreshUI(); return; }
      animateRoll(el, sides, (roll)=>{
        const success = roll >= chk.dc;
        addLog(rs, `Rolled ${roll} on d${sides} vs DC ${chk.dc}: ${success?'Success':'Fail'}.`, success?'good':'bad');
        chk.resolve(success, rs);
        state.pendingCheck = null;
        Array.from(elChoices.querySelectorAll('button')).forEach(b=>b.disabled=false);
        refreshUI();
        afterPick();
      });
    });
  });

  function renderTombs(){
    if(!state.tombstones.length){ elTombs.textContent='—'; return; }
    elTombs.innerHTML = state.tombstones.map(t=>{
      const d = new Date(t.time).toLocaleString();
      return `RIP <b>#${t.runId}</b> — depth ${t.depth}, gold ${t.gold} <span class="muted">(${d})</span>`;
    }).join('<br>');
  }

  // ---------- Scenario Generator (Large variety, low repeats) ----------
  const Biomes = ['Crypt','Forest','Cavern','Ruins','Desert','Coast','Bog','Tundra'];
  const Objectives = ['rescue a captive','salvage supplies','map a route','recover a relic','hunt a beast','escort a caravan','broker a truce','cleanse a curse'];
  const Obstacles = ['bandit ambush','arcane ward','rockfall maze','toxic spores','quicksand field','ghostly wails','flooded passage','mirror illusions'];
  const Twists = ['a rival arrives','time is short','the moonlight warps things','someone betrays you','an omen chills the air','you are being watched'];

  function rand(arr){ return arr[Math.floor(Math.random()*arr.length)]; }
  function titleCase(s){ return s.charAt(0).toUpperCase()+s.slice(1); }
  function makeScenario(depth){
    let tries=0; let id;
    let biome = rand(Biomes), obj = rand(Objectives), obs = rand(Obstacles), twist = Math.random()<0.6? rand(Twists):null;
    while(tries<50){
      id = `${biome}|${obj}|${obs}|${twist||''}`;
      if(!state.recentScenarios.includes(id)) break;
      biome = rand(Biomes); obj = rand(Objectives); obs = rand(Obstacles); twist = Math.random()<0.6? rand(Twists):null; tries++;
    }
    const title = `${biome}: ${titleCase(obj)}`;
    const text = `You reach a ${biome.toLowerCase()} where you must ${obj}. The path is threatened by ${obs}${twist?`, and ${twist}`:''}.`;
    const tags = [biome, obs.split(' ')[0], 'Depth '+depth];
    return { id, title, text, tags };
  }

  function pushRecent(id){
    state.recentScenarios.unshift(id);
    const MAX = 120; // cooldown length — prevents repeats for a long time
    if(state.recentScenarios.length>MAX) state.recentScenarios.pop();
    persist();
  }

  // ---------- Choice Factory (4 risk tiers every turn) ----------
  const Risks = {
    Safe:   { die:6,  baseDC:3,  dmg:1, loot:[0,1,2], bonus:0 },
    Bold:   { die:12, baseDC:7,  dmg:2, loot:[1,2,3,4], bonus:1 },
    Risky:  { die:20, baseDC:12, dmg:4, loot:[3,4,5,6,8], bonus:2 },
    Wild:   { die:20, baseDC:15, dmg:6, loot:[5,8,10,12], bonus:3 }
  };

  function dcFor(risk, depth){ return Math.min(20, risk.baseDC + Math.floor(depth/3) + (Math.random()<0.3?1:0)); }

  function fourChoicesFor(scenario, rs){
    const depth = rs.depth;
    const themed = {
      Safe: `Scout the area and avoid ${scenario.tags[1].toLowerCase()}`,
      Bold: `Negotiate or distract those behind the ${scenario.tags[1].toLowerCase()}`,
      Risky: `Exploit a weakness in the ${scenario.tags[1].toLowerCase()}`,
      Wild: `Charge straight through the ${scenario.tags[1].toLowerCase()}`
    };
    return Object.entries(Risks).map(([name, r])=>{
      const dc = dcFor(r, depth);
      return {
        text: themed[name],
        risk: name,
        die: r.die,
        dc,
        resolve: (ok,s)=>{
          if(ok){
            const g = r.loot[Math.floor(Math.random()*r.loot.length)];
            if(g>0){ s.gold += g; addLog(s, `${name} success: +${g} gold.`, 'good'); }
            else { s.resolve = Math.min(s.resolve+1, 8); addLog(s, `${name} success: +1 resolve.`, 'good'); }
          } else {
            s.hp -= r.dmg; addLog(s, `${name} backfires: -${r.dmg} HP.`, 'bad');
          }
        }
      };
    });
  }

  function step(){
    const rs = state.run; if(!rs || !rs.alive) return;
    rs.depth += 1;
    if(Math.random()<Math.min(0.45, rs.depth*0.02)){ rs.hp -= 1; addLog(rs,'Fatigue nips at you (-1 HP).','bad'); }
    if(isCampDepth(rs.depth)){ addLog(rs,'You reach a camp. You can retire safely here.'); }

    // New scenario each turn
    const sc = makeScenario(rs.depth);
    rs.scenario = sc; pushRecent(sc.id);
    renderChoices(rs, fourChoicesFor(sc, rs));
    refreshUI();
  }

  function afterPick(){
    const rs = state.run; if(!rs) return;
    if(rs.hp<=0){ rs.alive=false; addLog(rs, `You die at depth ${rs.depth}. Unbanked loot lost (${rs.gold} gold). Pass burned.`, 'bad');
      state.tombstones.unshift({ runId: rs.runId, depth: rs.depth, gold: rs.gold, time: Date.now() });
      if(state.tombstones.length>50) state.tombstones.pop();
      state.pass=null; state.run=null; persist(); renderTombs(); refreshUI(); return; }
    step();
  }

  function renderTombs(){
    if(!state.tombstones.length){ elTombs.textContent='—'; return; }
    elTombs.innerHTML = state.tombstones.map(t=>{
      const d = new Date(t.time).toLocaleString();
      return `RIP <b>#${t.runId}</b> — depth ${t.depth}, gold ${t.gold} <span class="muted">(${d})</span>`;
    }).join('<br>');
  }

  // ---------- Controls ----------
  elFaucet.onclick = ()=>{ state.walletMinor += 2000; persist(); updateWallet(); };
  elWithdraw.onclick = ()=>{ state.walletMinor = Math.max(0, state.walletMinor-500); persist(); updateWallet(); };

  elStart.onclick = ()=>{
    if(state.pass || state.run) return;
    const fee = lastFee; if(state.walletMinor < fee){ alert('Insufficient funds for entry fee. Use Add Test Coins.'); return; }
    state.walletMinor -= fee; persist(); updateWallet();
    const runId = Math.floor(Date.now()/1000).toString(36);
    state.pass = { runId, entryFeeMinor: fee };
    state.run = newRun(runId);
    addLog(state.run, `Run started. Entry fee: ${fmtMinor(fee)}.`);
    step();
    lastFee = dynamicEntryFee(); refreshUI();
  };

  elRetire.onclick = ()=>{
    const rs = state.run; if(!rs) return;
    if(!isCampDepth(rs.depth)){ addLog(rs,'You cannot retire here. Find a camp.'); refreshUI(); return; }
    const payoutMinor = rs.gold*50; // 1 gold = 0.50 FAKE
    state.walletMinor += payoutMinor; persist(); updateWallet();
    addLog(rs, `You retire with ${rs.gold} gold → ${fmtMinor(payoutMinor)}.`, 'good');
    rs.alive=false; state.pass=null; state.run=null; refreshUI();
  };

  // ---------- Init ----------
  renderTombs();
  refreshUI();
})();
</script></body>
</html>
